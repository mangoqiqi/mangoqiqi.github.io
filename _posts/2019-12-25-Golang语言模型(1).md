---
layout:     post
title:      Golang语言模型(1)-interface的底层原理浅析
subtitle:   go学习笔记
date:       2019-10-28
author:     Hxd
header-img: img/fiveyears.jpg
catalog: true
tags: 
    - Go
    - Golang
---

# 前言

Go语言在语法上相对C/C++来说，是比较简单的，基本语法多刷刷题目，然后工程的架构、目录规则等多看看其他开源项目，就应该能比较熟悉了。Go语言比较核心的设计
包括interface、内存模型、defer机制、goroutine实现与调度、cgo、数组与切片、Go编译器和连接器、GC实现这几大块。

注：所有源码基于 `go version go1.13.5 windows/amd64`

本篇笔记目的是了解interface的特性，并知道如何用好它。


# Interface定义

- 是一种类型
- 可以定义0个或多个方法（一组行为）
- 可以嵌入其他接口（目标类型方法集中必须拥有包含嵌入接口方法在内的全部方法才算实现了该接口）

如：

```
type Notifier interface {
　 notify()
}
```

这就定义了一个名为Notifier的interface，实现这个interface很简单，实现notify方法即可：

```
type User struct {
　 name　string
}

func (u *User) notify() {
　 fmt.Printf("Notify user name %s\n", u.name)
}
```
其他结构体也可以实现这个interface：

```
type Admin struct {
　 name　string
}

func (a *Admin) notify() {
　 fmt.Printf("Sending admin name %s\n", a.name)
}
```

这种实现是DuckType：类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接。

在调用notify的地方实现如下方法，即可实现多态性，即面向接口编程：

```
func sendNotify(n Notifier) {
   n.notify()
}
```
函数sendNotify接受一个实现了Notifier接口的值作为参数。
既然任意一个实体类型都能实现该接口，那么这个函数可以针对任意实体类型的值来执行notify方法，调用notify时，
会根据对象的实际定义来实现不同的行为，从而实现多态行为。


# 空interface

在Go中，有种空的interface类型，即没有任何方法的interface：interface{}。

```
type Any interface {}
```

对空接口类型来说，我们可以将任意一种类型的值赋值给空接口类型（就好比java的最高级父类）：

```
var any interface {}

    any = true
    any = 14.5
    any = "hello"
    ...
```

# 类型断言

在上面的多态函数的实现中，我们如何去判断传进来的n是User还是Admin呢？使用类型断言可以解决：

```
func sendNotify(n Notifier) {
    n.notify()
    switch v:= n.(type) {
      case *User:
        //is User role
      case *Admin:
        //is Admin role
      default:
        fmt.Println("don't know the type")
    }
}
```

# Interface的实现

任何interface类型，在内存中都是2个字长，32位机器上是8Byte，64位机器上是16Byte。

空interface的源码(src\runtime\runtime2.go line 197左右)：

```
type eface struct {
	_type *_type          // 类型指针
	data  unsafe.Pointer  // 数据区域指针
}
```
里面就两个指针，_type类型表示了类型的基本信息，类型大小，对齐信息，类型编号等，源码如下(src\runtime\type.go line 28左右)：

```
type _type struct {
	size       uintptr   // 类型大小
	ptrdata    uintptr   // size of memory prefix holding all pointers
	hash       uint32    // 哈希值
	tflag      tflag     // 类型的flag，与反射相关
	align      uint8     // 内存对齐相关
	fieldalign uint8     // 内存对齐相关
	kind       uint8     // 类型的编号
	alg        *typeAlg  // 类型的编号相关
	// gcdata stores the GC type data for the garbage collector.
	// If the KindGCProg bit is set in kind, gcdata is a GC program.
	// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
	gcdata    *byte      // 以下就是gc相关
	str       nameOff
	ptrToThis typeOff
}
```
Go语言各种数据类型都是在 _type 字段的基础上，增加一些额外的字段来进行管理的。

非空interface的实现(src\runtime\runtime2.go line 192左右):

```
type iface struct {
	tab  *itab
	data unsafe.Pointer
}

type itab struct {
	inter *interfacetype
	_type *_type
	hash  uint32     // copy of _type.hash. Used for type switches.
	_     [4]byte
	fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.
}
```

第一个itab中存放了类型信息，还有一个fun表示方法表。fun 数组的大小为 1，这里存储的是第一个方法的函数指针，
如果有更多的方法，在它之后的内存空间里继续存储。
从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。顺便提一句，这些方法是按照函数名称的字典序进行排列的。


interfacetype类型，src\runtime\type.go line 390左右：
```
type interfacetype struct {
	typ     _type       // 包装了 _type 类型
	pkgpath name        // 接口所定义的函数列表
	mhdr    []imethod   // 记录定义了接口的包名
}
```








参考：

https://www.cnblogs.com/qcrao-2018/p/10766091.html
http://shanks.leanote.com/post/interface%E8%AF%A6%E8%A7%A3

















