---
layout:     post
title:      Golang语言模型(1)-interface的底层原理浅析
subtitle:   go学习笔记
date:       2019-10-28
author:     Hxd
header-img: img/fiveyears.jpg
catalog: true
tags: 
    - Go
    - Golang
---

# 前言

Go语言在语法上相对C/C++来说，是比较简单的，基本语法多刷刷题目，然后工程的架构、目录规则等多看看其他开源项目，就应该能比较熟悉了。Go语言比较核心的设计
包括interface、内存模型、defer机制、goroutine实现与调度、cgo、数组与切片、Go编译器和连接器、GC实现这几大块。

注：所有源码基于 `go version go1.13.5 windows/amd64`

本篇笔记目的是了解interface的特性，并知道如何用好它。


# Interface定义

- 是一种类型
- 可以定义0个或多个方法（一组行为）
- 可以嵌入其他接口（目标类型方法集中必须拥有包含嵌入接口方法在内的全部方法才算实现了该接口）

如：

```
type Notifier interface {
　 notify()
}
```

这就定义了一个名为Notifier的interface，实现这个interface很简单，实现notify方法即可：

```
type User struct {
　 name　string
}

func (u *User) notify() {
　 fmt.Printf("Notify user name %s\n", u.name)
}
```
其他结构体也可以实现这个interface：

```
type Admin struct {
　 name　string
}

func (a *Admin) notify() {
　 fmt.Printf("Sending admin name %s\n", a.name)
}
```

这种实现是DuckType：类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接。

在调用notify的地方实现如下方法，即可实现多态性，即面向接口编程：

```
func sendNotify(n Notifier) {
   n.notify()
}
```
函数sendNotify接受一个实现了Notifier接口的值作为参数。
既然任意一个实体类型都能实现该接口，那么这个函数可以针对任意实体类型的值来执行notify方法，调用notify时，
会根据对象的实际定义来实现不同的行为，从而实现多态行为。


# 空interface

在Go中，有种空的interface类型，即没有任何方法的interface：interface{}。

```
type Any interface {}
```

对空接口类型来说，我们可以将任意一种类型的值赋值给空接口类型（就好比java的最高级父类）：

```
var any interface {}

    any = true
    any = 14.5
    any = "hello"
    ...
```

# 类型断言

在上面的多态函数的实现中，我们如何去判断传进来的n是User还是Admin呢？使用类型断言可以解决：

```
func sendNotify(n Notifier) {
    n.notify()
    switch v:= n.(type) {
      case *User:
        //is User role
      case *Admin:
        //is Admin role
      default:
        fmt.Println("don't know the type")
    }
}
```

# Interface的实现

任何interface类型，在内存中都是2个字长，32位机器上是8Byte，64位机器上是16Byte。

空interface的源码(src\runtime\runtime2.go line 197左右)：

```
type eface struct {
	_type *_type          // 类型指针
	data  unsafe.Pointer  // 数据区域指针
}
```
里面就两个指针，_type类型表示了类型的基本信息，类型大小，对齐信息，类型编号等，源码如下(src\runtime\type.go line 28左右)：

```
type _type struct {
	size       uintptr   // 类型大小
	ptrdata    uintptr   // size of memory prefix holding all pointers
	hash       uint32    // 哈希值
	tflag      tflag     // 类型的flag，与反射相关
	align      uint8     // 内存对齐相关
	fieldalign uint8     // 内存对齐相关
	kind       uint8     // 类型的编号
	alg        *typeAlg  // 类型的编号相关
	// gcdata stores the GC type data for the garbage collector.
	// If the KindGCProg bit is set in kind, gcdata is a GC program.
	// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
	gcdata    *byte      // 以下就是gc相关
	str       nameOff
	ptrToThis typeOff
}
```
Go语言各种数据类型都是在 _type 字段的基础上，增加一些额外的字段来进行管理的。

非空interface的实现(src\runtime\runtime2.go line 192左右):

```
type iface struct {
	tab  *itab
	data unsafe.Pointer
}

type itab struct {
	inter *interfacetype
	_type *_type
	hash  uint32     // copy of _type.hash. Used for type switches.
	_     [4]byte
	fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.
}
```

第一个itab中存放了类型信息，还有一个fun表示方法表。fun 数组的大小为 1，这里存储的是第一个方法的函数指针，
如果有更多的方法，在它之后的内存空间里继续存储。
从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。顺便提一句，这些方法是按照函数名称的字典序进行排列的。


interfacetype类型，src\runtime\type.go line 390左右：
```
type interfacetype struct {
	typ     _type       // 包装了 _type 类型
	pkgpath name        // 接口所定义的函数列表
	mhdr    []imethod   // 记录定义了接口的包名
}
```

# Interface的构造过程

先来看看这个例子：

```
package main

import (
    "strconv"
    "fmt"
)

type Stringer interface {
    String() string
}

type Binary uint64

func (i Binary) String() string {
    return strconv.FormatUint(i.Get(), 2)
}

func (i Binary) Get() uint64 {
    return uint64(i)
}

func main() {
    b := Binary(200)
    s := Stringer(b)
    fmt.Println(s.String())  // 输出11001000
}
```

执行命令： `go tool compile -S gotest.go > main.txt`

其中一段main函数的汇编代码如下：
```
"".main STEXT size=210 args=0x0 locals=0x58
	0x0000 00000 (gotest.go:22)	TEXT	"".main(SB), ABIInternal, $88-0
	0x0000 00000 (gotest.go:22)	MOVQ	TLS, CX
	0x0009 00009 (gotest.go:22)	MOVQ	(CX)(TLS*2), CX
	0x0010 00016 (gotest.go:22)	CMPQ	SP, 16(CX)
	0x0014 00020 (gotest.go:22)	JLS	200
	0x001a 00026 (gotest.go:22)	SUBQ	$88, SP
	0x001e 00030 (gotest.go:22)	MOVQ	BP, 80(SP)
	0x0023 00035 (gotest.go:22)	LEAQ	80(SP), BP
	0x0028 00040 (gotest.go:22)	FUNCDATA	$0, gclocals·69c1753bd5f81501d95132d08af04464(SB)
	0x0028 00040 (gotest.go:22)	FUNCDATA	$1, gclocals·568470801006e5c0dc3947ea998fe279(SB)
	0x0028 00040 (gotest.go:22)	FUNCDATA	$2, gclocals·bfec7e55b3f043d1941c093912808913(SB)
	0x0028 00040 (gotest.go:22)	FUNCDATA	$3, "".main.stkobj(SB)
	0x0028 00040 (gotest.go:24)	PCDATA	$0, $0
	0x0028 00040 (gotest.go:24)	PCDATA	$1, $0
	0x0028 00040 (gotest.go:24)	MOVQ	$200, (SP)
	0x0030 00048 (gotest.go:24)	CALL	runtime.convT64(SB)
	0x0035 00053 (gotest.go:25)	PCDATA	$0, $1
	0x0035 00053 (gotest.go:25)	LEAQ	go.itab."".Binary,"".Stringer(SB), AX
	0x003c 00060 (gotest.go:25)	PCDATA	$0, $0
	0x003c 00060 (gotest.go:25)	TESTB	AL, (AX)
	0x003e 00062 (gotest.go:24)	PCDATA	$0, $1
	0x003e 00062 (gotest.go:24)	MOVQ	8(SP), AX
	0x0043 00067 (gotest.go:25)	MOVQ	go.itab."".Binary,"".Stringer+24(SB), CX
	0x004a 00074 (gotest.go:25)	PCDATA	$0, $0
	0x004a 00074 (gotest.go:25)	MOVQ	AX, (SP)
	0x004e 00078 (gotest.go:25)	CALL	CX
	0x0050 00080 (gotest.go:25)	PCDATA	$0, $1
	0x0050 00080 (gotest.go:25)	MOVQ	8(SP), AX
	0x0055 00085 (gotest.go:25)	MOVQ	16(SP), CX
	0x005a 00090 (gotest.go:25)	PCDATA	$0, $0
	0x005a 00090 (gotest.go:25)	MOVQ	AX, (SP)
	0x005e 00094 (gotest.go:25)	MOVQ	CX, 8(SP)
	0x0063 00099 (gotest.go:25)	CALL	runtime.convTstring(SB)
	0x0068 00104 (gotest.go:25)	PCDATA	$0, $1
	0x0068 00104 (gotest.go:25)	MOVQ	16(SP), AX
	0x006d 00109 (gotest.go:25)	PCDATA	$1, $1
	0x006d 00109 (gotest.go:25)	XORPS	X0, X0
	0x0070 00112 (gotest.go:25)	MOVUPS	X0, ""..autotmp_16+64(SP)
	0x0075 00117 (gotest.go:25)	PCDATA	$0, $2
	0x0075 00117 (gotest.go:25)	LEAQ	type.string(SB), CX
	0x007c 00124 (gotest.go:25)	PCDATA	$0, $1
	0x007c 00124 (gotest.go:25)	MOVQ	CX, ""..autotmp_16+64(SP)
	0x0081 00129 (gotest.go:25)	PCDATA	$0, $0
	0x0081 00129 (gotest.go:25)	MOVQ	AX, ""..autotmp_16+72(SP)
```




参考：

https://www.cnblogs.com/qcrao-2018/p/10766091.html

http://shanks.leanote.com/post/interface%E8%AF%A6%E8%A7%A3

















