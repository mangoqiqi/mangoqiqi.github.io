---
layout:     post
title:      Git题目
subtitle:   不服气！
date:       2018-07-13
author:     Hxd
header-img: img/git.jpg
catalog: true
tags:
    - Git
---

# 题记
**此题目题解均为个人观点，通过网上查资料和实践而得，若有错误欢迎指正。**

**联系方式： 主页右边email**

## No.1

如果提示提交内容为空、不能提交，则最为合适的处理方式是：()

a) 执行 git status 查看状态，再执行 git add 命令选择要提交的文件，然后提交。 

b) 执行 git commit --allow-empty ，允许空提交。 

c) 执行 git commit -a ，提交所有改动。 

d) 执行 git commit --amend 进行修补提交。 

**答案：A**  首先看懂题目的意思，“提交内容为空”是什么意思呢？一种情况是：你在工作区做了修改，但是没有add就执行commit了，这种情况可以用git status命令查看：

```
$ git commit -m "No.1"
On branch master
Changes not staged for commit:
        modified:   readme.md

no changes added to commit

$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   readme.md

no changes added to commit (use "git add" and/or "git commit -a")
```
这个时候就可以用A选项的方式重新提交。
第二种情况是：你没有做任何修改就commit：
```
$ git commit -m "No.1"
On branch master
nothing to commit, working tree clean
```
这时候会有这个提示。
再看看B选项：git commit --allow-empty这个命令的意思是允许空提交。
```
git commit --allow-empty -m '[empty] initial commit'
```
这个提交不会对版本库有有效的更改，若这样提交，在第一种情况下工作区的修改也就没能提交到版本库。C选项的意思是add全部有改动的文件到缓存区。这样做会添加所有的改动。但是还是少了commit步骤。D选项：
```
git commit --amend 撤销上一次提交  并讲暂存区文件重新提交
类似的撤销修改命令：
git checkout -- <file>     拉取暂存区文件 并将其替换成工作区文件
git reset HEAD  -- <file>  拉取最近一次提交到版本库的文件到暂存区  改操作不影响工作区
```
amend操作可以帮我们 修改 最近一次提交到版本库的内容。例如：
```
$ git commit -m "No.1"
[master 36e396f] No.1
 1 file changed, 1 insertion(+), 1 deletion(-)

$ git lg
* 36e396f - (HEAD -> master) No.1 (3 seconds ago) <黄显东>
* 0728e96 - (dev) add a (3 days ago) <黄显东_20731>


$ git commit --amend
[master 316355a] No.1
 Date: Fri Jul 13 09:31:54 2018 +0800
 1 file changed, 1 insertion(+), 1 deletion(-)

$ git lg
* 316355a - (HEAD -> master) No.1 (26 seconds ago) <黄显东>
* 0728e96 - (dev) add a (3 days ago) <黄显东_20731>

```
可以看出36e396f已经被修改为316355a。
这个功能使用的场景是[git commit --amend用法](https://blog.csdn.net/zhujiangtaotaise/article/details/73505770)：
```
比方说，你的代码已经提交到git库，leader审核的时候发现有个Java文件代码有点问题，于是让你修改，通常有2种方法：

方法1：leader 将你提交的所有代码 abandon掉，然后你回去 通过git reset …将代码回退到你代码提交之前的版本，然后你修改出问题的Java文件，然后 git add xx.java xxx.java -s -m “Porject : 1.修改bug…” 
最后通过 git push origin HEAD:refs/for/branches

方法2： 
leader不abandon代码，你回去之后，修改出问题的Java文件，修改好之后，git add 该出问题.java 
然后 git commit –amend –no-edit, 
最后 git push origin HEAD:refs/for/branches。
```

## No.2

如果把项目中文件 hello.c 的内容破坏了，如何使其还原至原始版本？ 

 a) git reset -- hello.c 
 
 b) git checkout HEAD -- hello.c 
 
 c) git revert hello.c 
 
 d) git update hello.c 

 **答案：C**  假如hello.c文件在工作区修改了，已经add而且hi没有commit，可以用git checkout -- hello.c 命令从缓存区撤回到工作区的修改，如果已经commit可以用git reset HEAD -- hello.c 命令从版本库撤回到缓存区，再用git checkout HEAD -- hello.c命令。(HEAD指向头指针，不加的话默认为当前分支)

 git revert hello.c 命令撤销 某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交[git revert 用法](https://www.cnblogs.com/0616--ataozhijia/p/3709917.html)

 比如：
 ```

$ git lg
* fdfc012 - (HEAD -> master) No.2 (6 seconds ago) <黄显东>
* 2ec083f - No.1 (31 minutes ago) <黄显东>
* 316355a - No.1 (34 minutes ago) <黄显东>


$ git revert HEAD
[master a590300] Revert "No.2"


$ git lg
* a590300 - (HEAD -> master) Revert "No.2" (11 seconds ago) <黄显
东>
* fdfc012 - No.2 (88 seconds ago) <黄显东>
* 2ec083f - No.1 (32 minutes ago) <黄显东>
* 316355a - No.1 (34 minutes ago) <黄显东>
```
D选项，git update 命令好像找不到。

## No.3

修改的文档 meeting.doc 尚未提交，因为错误地执行了 git reset --hard 导致数据丢失。丢失的数据能找回么？

a) 不能。执行硬重置使工作区文件被覆盖，导致数据丢失无法找回。 

b) 能。可以通过 git checkout HEAD@{1} -- meeting.doc 找回。 

c) 不确定。如果在重置前执行了 git add 命令将 meeting.doc 加入了暂存区，则可以在对象库中处于悬空状态的文件中找到。 

d) 不能。因为未提交所以无法找回。 

**答案：A**  做如下测试：
```
首先，我们将readme.md文件写为no.1，然后提交信息为no.1,再修改为no.2，再提交，提交信息为no.2：

$ git reflog
65c4948 (HEAD -> master) HEAD@{0}: commit: no.2
30ddbae HEAD@{1}: commit: no.1

$ git lg
* 65c4948 - (HEAD -> master) no.2 (33 seconds ago) <黄显东>
* 30ddbae - no.1 (52 seconds ago) <黄显东>

然后再改为no.3但是没有提交，而且执行：
$ git reset --hard HEAD^
HEAD is now at 30ddbae no.1

此时我们修改为no.3的readme.md文件已经被退回到no.1.接着按照B选项操作：
$ git reflog
30ddbae (HEAD -> master) HEAD@{0}: reset: moving to HEAD^
65c4948 HEAD@{1}: commit: no.2
30ddbae (HEAD -> master) HEAD@{2}: commit: no.1

$ git checkout  HEAD@{1} -- readme.md
$ cat readme.md
no.2
可以看出，只能退回到no.2版本，之前所做的修改丢失了。所以B答案不对。
```
以上对no.3的修改是尚未add的，下面进行有add的情况：
```
$ git add readme.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   readme.md

$ git lg
* 4d457d4 - (HEAD -> master) no2 (49 seconds ago) <黄显东>
* 92a5a70 - no1 (61 seconds ago) <黄显东>

$ git reflog
4d457d4 (HEAD -> master) HEAD@{0}: commit: no2
92a5a70 HEAD@{1}: commit: no1

然后执行reset：
$ git reset --hard HEAD^
HEAD is now at 92a5a70 no1
现在的版本是no.1.然后执行B选项操作：
$ git reflog
92a5a70 (HEAD -> master) HEAD@{0}: reset: moving to HEAD^
4d457d4 HEAD@{1}: commit: no2
92a5a70 (HEAD -> master) HEAD@{2}: commit: no1

$ git checkout  HEAD@{1} -- readme.md
$ cat readme.md
no.2
还是为no.2，并不是no.3从而不能找回.
```
深入了解git reset 操作：

![git](http://pbqgh436d.bkt.clouddn.com/18-7-15/75274466.jpg)

命令格式：git reset  [--soft | --mixed | --hard] [< commit >]
使用参数--hard，如：git reset --hard <commit>会执行上图中的全部动作1，2，3即：
- 替换引用的指向，引用指向新的提交ID
- 替换暂存区，替换后，暂存区的内容和引用指向的目录树一致
- 替换工作区，替换后，工作区的内容变得和暂存区一致，也和HEAD所指向的目录树内容相同
```
$ git reset --hard
HEAD is now at e5d3f96 5

$ git reset --hard HEAD
HEAD is now at e5d3f96 5

$ git reset --hard HEAD^
HEAD is now at 4202a57 4
```
使用参数--soft，如：git reset --soft <commit> 会执行上图中的操作1

使用参数--mixed或不使用参数（默认为--mixed）,如：git reset <commit>会执行上图中的操作1和操作2

命令：git reset 仅用HEAD指向的目录树重置暂存区，工作区不受影响，相当于将之前用 git add命令更新到暂存区的内容撤出暂存区。引用也未改变，因为引用重置到HEAD相当于没有重置

命令：git reset HEAD  同上

命令：git reset --filename 仅将文件filename的改动撤出暂存区，暂存区中其他文件不改变，相当于git add filename的反向操作

命令：git reset HEAD filename同上

命令：git reset --soft HEAD^  工作区和暂存区不改变，但是引用向前回退一次，当对最新提交的提交说明或提交的更改不满意时，撤消最新的提交以便重新提交。

命令：git reset HEAD^ 工作区不改变，暂存区会回退到上一次提交之前，引用也回退一次。

命令：git reset --mixed HEAD^ 同上

命令：git reset --hard HEAD^ 彻底撤消最近的提交，引用回退到前一次，而且工作区和暂存区都会退到上一次提交的状态，自上一次以来的提交全部丢失。

## No.4

仅将工作区中修改的文件添加到暂存区（新增文件不添加），以备提交，用什么命令标记最快？ 

a) git add -A 

b) git add -p 

c) git add -i 

d) git add -u

**答案：D**  来深入了解一下git add 命令：

